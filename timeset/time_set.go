// Code generated by internal/numeric.tmpl, DO NOT EDIT.

package timeset

import (
	"sync"
	"time"
)

type set struct {
	mu   sync.RWMutex
	data map[int64]time.Time
}

// New create and return instance of time set
func New(times ...time.Time) *set {
	s := NewWithSize(len(times))
	s.Adds(times...)
	return s
}

// New create and return instance of time set
func NewWithSize(size int) *set {
	return &set{
		data: make(map[int64]time.Time, size),
	}
}

// Add item to the set.
func (s *set) Add(item time.Time) {
	s.mu.Lock()
	defer s.mu.Unlock()

	s.data[item.Unix()] = item
}

// Add items to the set.
func (s *set) Adds(items ...time.Time) {
	s.mu.Lock()
	defer s.mu.Unlock()

	for _, item := range items {
		s.data[item.Unix()] = item
	}
}

// Remove item from the set.
func (s *set) Remove(item time.Time) {
	s.mu.Lock()
	defer s.mu.Unlock()

	delete(s.data, item.Unix())
}

// Remove items from the set.
func (s *set) Removes(items ...time.Time) {
	s.mu.Lock()
	defer s.mu.Unlock()

	for _, item := range items {
		delete(s.data, item.Unix())
	}
}

// Exist determines whether the item is exists in the set.
func (s *set) Exist(item time.Time) bool {
	s.mu.RLock()
	defer s.mu.RUnlock()

	_, ok := s.data[item.Unix()]
	return ok
}

// List convert set to an array.
func (s *set) List(item time.Time) []time.Time {
	s.mu.RLock()
	defer s.mu.RUnlock()

	i := 0
	l := make([]time.Time, len(s.data))
	for _, val := range s.data {
		l[i] = val
		i++
	}

	return l
}
